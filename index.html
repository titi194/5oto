<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Emoji Block Bouncer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            background-color: #7ab3f1; /* Sky Blue */
            display: block;
            cursor: pointer;
        }
        #rotate-device-message {
            display: none;
            color: white;
            text-align: center;
            font-size: 1.5em;
        }
        @media (orientation: portrait) {
            #gameCanvas {
                display: none;
            }
            #rotate-device-message {
                display: block;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="rotate-device-message">
        <p>Please rotate your device to landscape mode to play.</p>
    </div>

<script>
// ======================================================================================
// GAME SCRIPT - CREATIVE EMOJI/TEXT VERSION
// ======================================================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- AUDIO SETUP ---
const audio = {
    bgm: new Audio('https://www.dropbox.com/scl/fi/2oea5f5x1ye2b6hwdegot/5oto-BGM.mp3?rlkey=trsq4q6xwdi2dyxfyfna1c27z&dl=1'),
    jump: new Audio('https://www.dropbox.com/scl/fi/jw4nc9cvrebquzbmh6lj5/jump-scare-scream-x.mp3?rlkey=hlhw86ww96rh392jt7t0u846v&dl=1'),
    gameOver: new Audio('https://www.dropbox.com/scl/fi/6hiazk6htgw5m1umjdqoo/GAME-OVER-5oto.mp3?rlkey=u2a9bk6cayl757lxiyredluvw&dl=1'),
    mushroom: new Audio('https://www.dropbox.com/scl/fi/7v7qosar34g0srjimuzgg/MEHDI-GIFT-TRAP.mp3?rlkey=ysbc9oufg35qhaglguy51041y&st=k1prokrk&dl=1')
};
audio.bgm.loop = true;

function playSound(sound) {
    if (soundOn) {
        sound.currentTime = 0;
        sound.play().catch(e => console.log("Audio play failed:", e));
    }
}


// --- 1. GAME CONFIGURATION AND STATE ---
const config = {
    width: 800,
    height: 450,
    playerSpeed: 3.5,
    jumpForce: 13,
    gravity: 0.6,
    scorePerSecond: 10,
    poopPenalty: 250,
    mushroomBonus: 500,
    platformSegmentWidth: 500,
    groundLevelY: 380,
    obstacleSize: 40, // CORRECTED: Uniform size for all obstacles
};

let gameState = 'MENU';
let score = 0;
let highScore = localStorage.getItem('emojiBlockHighScore') || 0;
let soundOn = true;
let mushroomSpawnTimer = 15;
let obstacleSpawnTimer = 3; 
let floatingTexts = [];

// --- 2. GAME OBJECTS (PLAYER, PLATFORMS, etc.) ---
const camera = {
    x: 0,
    y: 0,
    update: function(target) {
        if (target.x - this.x > 300) {
            this.x = target.x - 300;
        }
    }
};

let player = {};
function resetPlayer() {
    player = {
        x: 100,
        y: 100,
        vx: 0,
        vy: 0,
        width: 40,
        height: 40,
        isGrounded: false,
        health: 3,
        faceState: 'playing',
        faceTimer: 0,
    };
}

let platforms = [];
let items = [];
let obstacles = [];
let clouds = [];

function generateLevel() {
    platforms = [];
    for (let i = -2; i < (config.width / config.platformSegmentWidth) + 2; i++) {
        const platformX = i * config.platformSegmentWidth;
        platforms.push({ x: platformX, y: config.groundLevelY, width: config.platformSegmentWidth, height: config.height - config.groundLevelY });
    }
    items = [];
    obstacles = [];
    clouds = [];
    for(let i=0; i < 20; i++) {
        clouds.push({ x: Math.random() * 4000, y: Math.random() * 150, size: 20 + Math.random() * 30, speed: 0.1 + Math.random() * 0.2 });
    }
}

// UI button definitions
const uiButtons = {
    start:       { x: config.width/2 - 100, y: 150, w: 200, h: 50, text: 'START' },
    highScore:   { x: config.width/2 - 100, y: 220, w: 200, h: 50, text: 'HIGH SCORE' },
    jump:        { x: config.width - 150, y: config.height - 120, w: 110, h: 110, text: 'JUMP', color: 'rgba(255, 255, 255, 0.8)' },
    pause:       { x: config.width - 120, y: 20, w: 100, h: 40, text: 'PAUSE' },
    sound:       { x: config.width - 60, y: 75, w: 40, h: 40, text: soundOn ? 'ðŸ”Š' : 'ðŸ”‡' },
    resume:      { x: config.width/2 - 100, y: 150, w: 200, h: 50, text: 'RESUME' },
    restart:     { x: config.width/2 - 100, y: 150, w: 200, h: 50, text: 'RESTART' },
    menu:        { x: config.width/2 - 100, y: 220, w: 200, h: 50, text: 'MENU' }
};

// --- 3. GAME LOGIC & UPDATES ---
function update(dt) {
    if (gameState !== 'PLAYING') return;

    // Player Update
    player.vx = config.playerSpeed;
    player.x += player.vx;
    player.vy += config.gravity;
    player.y += player.vy;
    player.isGrounded = false;
    
    // --- Dynamic Content Spawning ---
    mushroomSpawnTimer -= dt;
    if (mushroomSpawnTimer <= 0) {
        items.push({ x: camera.x + config.width + 100, y: config.groundLevelY - 32, emoji: 'ðŸ„', width: 32, height: 32 });
        mushroomSpawnTimer = 20;
    }

    // CORRECTED: Rhythmic Obstacle Spawner
    obstacleSpawnTimer -= dt;
    if (obstacleSpawnTimer <= 0) {
        const numToSpawn = Math.random() < 0.7 ? 1 : 2; // 70% chance for 1, 30% for 2
        for (let i = 0; i < numToSpawn; i++) {
            const obstacleTypes = ['ðŸ’©', 'ðŸš½', 'ðŸ¦¶ðŸ»'];
            const choice = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const spawnX = camera.x + config.width + 100 + (i * 80); // Space them out
            obstacles.push({
                emoji: choice,
                x: spawnX,
                y: config.groundLevelY - config.obstacleSize,
                width: config.obstacleSize,
                height: config.obstacleSize,
            });
        }
        obstacleSpawnTimer = 2.5; // FIXED spawn rate
    }

    floatingTexts.forEach(ft => ft.lifetime -= dt);
    floatingTexts = floatingTexts.filter(ft => ft.lifetime > 0);

    // --- Collision Detection ---
    // Item Collision
    items.forEach((entity) => {
        if (player.x < entity.x + entity.width && player.x + player.width > entity.x &&
            player.y < entity.y + entity.height && player.y + player.height > entity.y) {
            
            if (entity.emoji === 'ðŸ„') {
                playSound(audio.mushroom);
                player.faceState = 'relaxed';
                player.faceTimer = 3;
                score += config.mushroomBonus;
                floatingTexts.push({ text: 'VIAGRA', x: entity.x, y: entity.y - 10, lifetime: 2.0, color: '#fbc531', size: 24 });
                items = items.filter(i => i !== entity);
            }
        }
    });

    // CORRECTED: Smart Obstacle Collision
    obstacles.forEach((entity) => {
        if (player.x < entity.x + entity.width && player.x + player.width > entity.x &&
            player.y < entity.y + entity.height && player.y + player.height > entity.y) {

            const isTopCollision = player.vy > 0 && (player.y + player.height - player.vy) <= entity.y;

            if ((entity.emoji === 'ðŸš½' || entity.emoji === 'ðŸ¦¶ðŸ»') && isTopCollision) {
                // LAND SAFELY on Toilet or Foot
                player.isGrounded = true;
                player.vy = 0;
                player.y = entity.y - player.height;
            } else {
                // All other cases: side collision, or any collision with Poop
                if (entity.emoji === 'ðŸš½') {
                    // Side collision with Toilet stops the player
                    player.x = entity.x - player.width;
                } else {
                    // Any collision with Poop, or side collision with Foot is damaging
                    player.health--;
                    player.faceState = 'losing';
                    player.faceTimer = 0.5;
                    obstacles = obstacles.filter(o => o !== entity);
                    if (player.health <= 0) gameOver();
                }
            }
        }
    });
    
    // Main Ground Collision (if not already on an obstacle platform)
    if (!player.isGrounded && player.y + player.height >= config.groundLevelY) {
        player.y = config.groundLevelY - player.height;
        player.vy = 0;
        player.isGrounded = true;
    }

    if (player.faceTimer > 0) {
        player.faceTimer -= dt;
        if (player.faceTimer <= 0) player.faceState = 'playing';
    }
    
    if (player.y > config.height + 100) gameOver();
    
    score += config.scorePerSecond * dt;
    camera.update(player);

    // Infinite world cleanup
    platforms = platforms.filter(p => p.x + p.width > camera.x);
    items = items.filter(i => i.x + i.width > camera.x);
    obstacles = obstacles.filter(o => o.x + o.width > camera.x);
}

// --- 4. RENDERING (DRAWING TO CANVAS) ---
function draw() {
    ctx.clearRect(0, 0, config.width, config.height);
    ctx.fillStyle = '#74b9ff';
    ctx.fillRect(0, 0, config.width, config.height);
    
    ctx.save();
    clouds.forEach(cloud => {
        const cloudX = (cloud.x - camera.x * cloud.speed) % (config.width + 200) - 100;
        ctx.font = `${cloud.size}px serif`;
        ctx.fillText('â˜ï¸', cloudX, cloud.y);
    });
    ctx.restore();
    
    ctx.save();
    ctx.translate(-camera.x, 0);

    // World Objects
    platforms.forEach(p => {
        ctx.fillStyle = '#6ab04c'; ctx.fillRect(p.x, p.y, p.width, 15);
        ctx.fillStyle = '#a0522d'; ctx.fillRect(p.x, p.y + 15, p.width, p.height - 15);
    });

    [...items, ...obstacles].forEach(entity => {
        ctx.font = `${entity.height}px serif`;
        ctx.fillText(entity.emoji, entity.x, entity.y + entity.height);
    });
    
    // Player
    ctx.font = `${player.height}px serif`;
    ctx.textAlign = 'center';
    let faceEmoji = 'ðŸ˜Ž';
    if(player.faceState === 'losing') faceEmoji = 'ðŸ˜¡';
    if(player.faceState === 'relaxed') faceEmoji = 'ðŸ˜Œ';
    ctx.fillText(faceEmoji, player.x + player.width/2, player.y + player.height - 3);

    floatingTexts.forEach(ft => drawText(ft.text, ft.x, ft.y, ft.size, ft.color));
    
    ctx.restore();

    // UI Drawing
    if (gameState !== 'PLAYING') {
        ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
        ctx.fillRect(0, 0, config.width, config.height);
    }
    
    switch(gameState) {
        case 'MENU':
            drawButton(uiButtons.start, '#ff9f43', '#ffffff');
            drawButton(uiButtons.highScore, '#ff9f43', '#ffffff');
            drawText(`High Score: ${Math.floor(highScore)}`, config.width / 2, 320, 24, 'white');
            break;
        case 'PLAYING':
            drawHUD();
            drawButton(uiButtons.jump, 'rgba(255,255,255,0.7)', 'black');
            drawButton(uiButtons.pause, '#ff9f43', '#ffffff');
            drawButton(uiButtons.sound, 'transparent');
            break;
        case 'PAUSED':
            drawHUD(); drawOverlay();
            drawButton(uiButtons.resume, '#45aaf2', '#ffffff');
            drawButton(uiButtons.menu, '#ff9f43', '#ffffff');
            break;
        case 'GAMEOVER':
            drawHUD(); drawOverlay();
            drawButton(uiButtons.restart, '#45aaf2', '#ffffff');
            drawButton(uiButtons.menu, '#ff9f43', '#ffffff');
            drawText('GAME OVER', config.width / 2, 110, 48, '#e84118');
            if(score > highScore) drawText('New High Score!', config.width / 2, 320, 24, '#fbc531');
            break;
    }
}

function drawHUD() {
    ctx.font = '32px serif';
    for(let i = 0; i < player.health; i++) ctx.fillText('â¤ï¸', 30 + i * 40, 45);
    drawText(`Score: ${Math.floor(score)}`, 20, 80, 24, 'white', 'left');
}

function drawOverlay() {
    ctx.fillStyle = 'rgba(110, 85, 61, 0.7)';
    ctx.fillRect(0, 0, config.width, config.height);
}

function drawButton(btn, bgColor, textColor) {
    if (btn === uiButtons.jump) {
        ctx.fillStyle = bgColor;
        ctx.beginPath(); ctx.arc(btn.x + btn.w/2, btn.y + btn.h/2, btn.w/2, 0, Math.PI * 2); ctx.fill();
        drawText('JUMP', btn.x + btn.w/2, btn.y + btn.h/2 + 8, 30, textColor);
    } else {
        if(bgColor !== 'transparent') {
            ctx.fillStyle = bgColor; ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        }
        drawText(btn.text, btn.x + btn.w / 2, btn.y + btn.h / 2 + 8, btn.w === 40 ? 30 : 24, textColor);
    }
}

function drawText(text, x, y, size, color, align = 'center') {
    ctx.fillStyle = color;
    ctx.font = `bold ${size}px 'Courier New', monospace`;
    ctx.textAlign = align;
    ctx.fillText(text, x, y);
}

// --- 5. GAME STATE & INPUT ---
function resetGame() {
    score = 0; camera.x = 0;
    mushroomSpawnTimer = 15;
    obstacleSpawnTimer = 3; 
    floatingTexts = [];
    resetPlayer();
    generateLevel();
}

function startGame() {
    resetGame();
    gameState = 'PLAYING';
    if (soundOn) audio.bgm.play();
}

function gameOver() {
    if (gameState === 'GAMEOVER') return;
    audio.bgm.pause();
    playSound(audio.gameOver);
    gameState = 'GAMEOVER';
    if(score > highScore) {
        highScore = score;
        localStorage.setItem('emojiBlockHighScore', highScore);
    }
}

function handleInput(x, y) {
    const isInside = (pos, rect) => pos.x > rect.x && pos.x < rect.x + rect.w && pos.y > rect.y && pos.y < rect.y + rect.h;
    const isInsideCircle = (pos, c) => (Math.sqrt((pos.x-(c.x+c.w/2))**2 + (pos.y-(c.y+c.h/2))**2)) < c.w/2;
    
    let targetButton = null;
    if (gameState === 'PLAYING') targetButton = isInsideCircle({x,y}, uiButtons.jump) ? uiButtons.jump : isInside({x,y}, uiButtons.pause) ? uiButtons.pause : isInside({x,y}, uiButtons.sound) ? uiButtons.sound : null;
    else if (gameState === 'PAUSED') targetButton = isInside({x,y}, uiButtons.resume) ? uiButtons.resume : isInside({x,y}, uiButtons.menu) ? uiButtons.menu : null;
    else if (gameState === 'MENU') targetButton = isInside({x,y}, uiButtons.start) ? uiButtons.start : isInside({x,y}, uiButtons.highScore) ? uiButtons.highScore : null;
    else if (gameState === 'GAMEOVER') targetButton = isInside({x,y}, uiButtons.restart) ? uiButtons.restart : isInside({x,y}, uiButtons.menu) ? uiButtons.menu : null;

    if (targetButton === uiButtons.jump && player.isGrounded) { player.vy = -config.jumpForce; playSound(audio.jump); }
    else if (targetButton === uiButtons.pause) { gameState = 'PAUSED'; audio.bgm.pause(); }
    else if (targetButton === uiButtons.sound) { 
        soundOn = !soundOn; uiButtons.sound.text = soundOn ? 'ðŸ”Š' : 'ðŸ”‡';
        if (soundOn && gameState === 'PLAYING') audio.bgm.play(); else audio.bgm.pause();
    }
    else if (targetButton === uiButtons.resume) { gameState = 'PLAYING'; if(soundOn) audio.bgm.play(); }
    else if (targetButton === uiButtons.menu) { gameState = 'MENU'; audio.bgm.pause(); audio.bgm.currentTime = 0; }
    else if (targetButton === uiButtons.start || targetButton === uiButtons.restart) startGame();
}

function setupInputListeners() {
    const getPos = (canvas, evt) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = evt.clientX || (evt.touches && evt.touches[0].clientX);
        const clientY = evt.clientY || (evt.touches && evt.touches[0].clientY);
        return { x: (clientX - rect.left) / rect.width * config.width, y: (clientY - rect.top) / rect.height * config.height };
    }
    canvas.addEventListener('mousedown', (e) => handleInput(getPos(canvas, e).x, getPos(canvas, e).y));
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(getPos(canvas, e).x, getPos(canvas, e).y); }, { passive: false });
}

// --- 6. MAIN GAME LOOP ---
let lastTime = 0;
function gameLoop(timestamp) {
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if(gameState === 'PLAYING') update(dt || 0);
    draw();
    requestAnimationFrame(gameLoop);
}

// --- 7. INITIALIZATION ---
canvas.width = config.width; canvas.height = config.height;
resetPlayer();
generateLevel();
setupInputListeners();
lastTime = performance.now();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
